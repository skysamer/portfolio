# :pushpin: 도로공사 교통예보시스템 고도화 프로젝트
>도로공사 교통예보시스템 고도화 프로젝트
>

</br>

## 1. 제작 기간 & 참여 인원
- 2021년 6월1일 ~ 2021년 12월 24일
- SI 프로젝트
- 프론트엔드 / 백엔드 각 1명

</br>



## 2. 사용 기술
#### `Back-end`
  - Java 8
  - Spring 3 
  - MyBatis
  - Oracle 11g
#### `Front-end`
  - JQuery

</br>

## 3. 핵심 기능
- 본선 고속도로의 ic-ic 구간 별 교통량 데이터 표출
- 본선 고속도로를 우회하여 주행하는 개별차량에 대한 데이터 표출(속도, 시간 등)
- 분석 휴게소 별 개별 차량에 대한 휴게소 이용 데이터 표출(이용시간, 구간 통과 시간, 교통량 등)

## 4. 핵심 알고리즘 설계

### 4.1. 경로형 교통량 통계

- 일자별 개별차량에 대한 경로형 데이터를 저장하고 있는 테이블과 본선 고속도로 노선 별 노드 데이터를 저장하는 테이블을 매핑
- 개별차량이 시간순으로 지나간 각 노선 rse의 이정 데이터를 산출
- 개별챠량이 지나간 노선 별 rse의 이정을 각 노선 별 ic-ic구간이 저장되어 있는 테이블에서 ic구간사이에 이정을 넣어서 매핑
- 차종 및 시간대별로 교통량을 집계하여 표출

### 4.2. 휴게소 분석

- 일자별 개별차량에 대한 주행 데이터를 저장하고 있는 테이블과 본선 고속도로 노선 별 데이터를 저장하는 테이블을 지점별 컬럼으로 매핑
- 매핑된 전처리 테이블을 휴게소 지점별 데이터를 저장하는 테이블과 매핑
- 자체적으로 계산한 클러스터링 계수값을 휴게소 군집별로 매핑
- 휴게소 양 끝에 설치된 구간검지기 데이터를 활용하여 지점별 이용차량 주행시간, 교통량, 차량 통과시간 데이터를 산출

### 4.3. 우회도로 현황 / 분석

- 일자별 개별차량에 대한 주행 데이터를 저장하고 있는 테이블과 본선 고속도로 노선 별 데이터를 저장하는 테이블을 지점별 컬럼으로 매핑
- 개별차랑을 시간순으로 정렬하여 개별차량의 통과 경로 데이터를 구성
- 본선 고속도로를 빠져나와 TG를 통과한 차량을 모아서 1차적으로 우회차량으로 분류
- TG를 통과한 차량 중 본선 평균 속도가 80 미만인 경우에만 차량이 우회를 했을 것으로 판단하여 2차적으로 우회차량 분류
- 본선 고속도로의 TG 구간 별로 본선 이용 차량과 우회차량을 비교하여 교통량 및 우회 시간 데이터 산출
- 기존 우회차량 데이터 및 문자정보와 비교하여 우회도로 통행시간 및 속도 데이터 산출

## 5. 플로우 차트

### 5.1. 전체 흐름
<img width="828" src="https://user-images.githubusercontent.com/73572543/141735287-7c5002a1-6779-4e7b-ab1f-3afe7af1e41f.png">

### 5.2. 사용자 요청

- **데이터 항목 별 조건 설정** 
  - 날짜, 노선, 구간, 방향 등 다양한 조건을 설정합니다.
  - 특정 조건에 맞는 데이터가 없을 경우 일치하는 검색결과 없다는 메시지를 띄웁니다.

- **Ajax 비동기 요청** 
  - 데이터 표 조회 버튼 클릭 시, 데이터를 표출하는 POST 요청을 비동기로 날립니다.

### 5.3. Controller

- **요청 처리** 
  - Controller에서는 요청을 화면단에서 넘어온 요청을 HttpServlet 객체로 받고, Service 계층에 조건 파라미터 값을 전달합니다.

- **응답 처리** 
  - Service 계층에서 넘어온 데이터를 MappingJacksonJsonView 객체를 활용하여 json 객체로 전달.

### 5.4. Service

- **요청 처리** 
  - HttpServletRequest 파라미터 값의 해시 키값을 추출합니다.
  - 매핑되는 value값을 문자열로 변환합니다.
  - 변환된 파라미터 값을 HashMap 객체를 생성하여 저장합니다.

- **응답 처리** 
  - DAO 객체에서 받아온 쿼리 결과값을 CaseInsensitiveMap 객체의 List객체를 생성하여 받습니다.
  - 생성된 List값을 Controller에 전달합니다.


### 5.5. DAO

- **요청 밎 응답 처리** 
  - Service에서 가져온 파라미터 값을 Map 객체로 쿼리에 던집니다
  - SqlSession 객체를 주입하여 쿼리 결과값을 가져옵니다.
  - 저장된 데이터는 다시 Repository - Service - Controller를 거쳐 화면단에 송출됩니다.

</div>
</details>

</br>

## 5. 핵심 트러블 슈팅
### 5.1. SQL 성능 개선 문제
- 일자별 개별차량 데이터 수가 약 3~5천만건에 이르기 때문에 성능 이슈 해결이 가장 중요

- 500줄이 넘어가는 알고리즘에 중간 테이블 및 최종 결과 테이블을 구성하여 1차적으로 성능을 해결

- 중간 테이블 및 결과 테이블에 데이터를 insert하는 작업을 프로시저를 활용하여 일괄 처리

- 작성된 프로시저에 일별 커서를 지정하고, Loop문을 생성하여 기존에 저장된 일자별 이력데이터 insert 작업을 진행

- 이후 생성되는 최신 데이터는 작성된 프로시저를 DB 스케줄러에 등록하여 자동화

### 5.2. DB서버가 2개로 분리된 문제
- DB서버가 2개로 분리되었는데 각 DB에 존재하는 테이블을 JOIN하여 데이터를 산출해야하는 문제 존재

- 각 DB의 테이블에서 가져온 결과값을 자바코드의 list에 저장

- if문으로 조인 조건을 생성하고 반복문으로 전체 list를 순회하며 조인. 이때 신규 list를 생성하여 조인 결과값 저장

- group by, sum 등의 그룹 및 집계함수 구현의 경우, 조인한 list를 loop로 순회하며 조건이 맞을때마다 집계하는 방식으로 구현

- 최종 결과값을 만들어둔 결과 테이블에 insert

### 5.3. 자바에서 테이블을 join한 결과값 조회의 속도 개선 문제
- 어플리케이션 내 자바 service단에서 직접 조회를 연산하여 데이터를 표출하니 약15초 정도 조회가 걸리는 문제가 발생

- 단독 자바 프로젝트를 생성하여, 직접 DB커넥션을 연결하고, 코드내에서 직접 조인 및 연산을 수행

- 최종 결과값을 저장할 테이블 connection을 생성하여 연산된 결과값을 테이블에 저장

- 완성된 코드를 jar파일로 아카이브하여 자바 응용프로그램 생성

- 작성된 자바 응용프로그램을 리눅스 crontab을 활용하여 매일 8시에 응용프로그램이 실행되어 자동으로 일별 데이터를 결과 테이블에 insert되도록 설정

</div>
</details>

</br>

## 6. 그 외 트러블 슈팅
<details>
<summary>조건을 동적으로 지정하는 문제</summary>
<div markdown="1">

- MyBatis Dynamic SQL 활용
- if test 구문을 활용하여 필요한 경우에만 조건절을 삽입

</div>
</details>

<details>
<summary>INSERT INTO SELECT 성능 개선 문제</summary>
<div markdown="1">

- /*+append*/ 힌트 활용
- nologging 테이블로 변경

</div>
</details>

## 7. 회고록
### 7.1. 설계와 협의의 중요성
신입 개발자로 입사하여 첫 프로젝트였다. 그 전에는 무작정 요구하는 기능을 구현하면 되는 줄 알았다. 개발 사수가 없었기에 무엇을 먼저 시작해야 하는지도 알지 못했다.
그러나 본격적으로 프로젝트가 시작되고 나서 누군가 기능과 요구사항을 말해주는 것이 아닌 우리가 먼저 화면설계 및 네이밍 컨벤션을 지정하고, 
발주처와 끊임없는 협의의 과정이 필요하다는 것을 알았다.

제대로된 화면설계서 없이는 무엇을 개발해야 되는지 전혀 알지 못했고 네이밍 컨벤션에 대한 협의가 이루어지지 않으니 개발코드가 자꾸만 꼬이곤 했다.

설령 화면설계서를 온전히 작성했다 하더라도, 발주처와 제대로 된 협의가 없다면 그것은 반쪽짜리 설계서이며, 
설계문서가 완전히 합의 되기 전까지는 이전의 개발은 단지 일을 두배로 더해야 한다는 것을 의미했다.

또한 설계라는 것은 어떠한 기능을 구현할지를 정하는 것 이상으로
그러한 기능이 합리적인지 그 기능과 연관된 다른 기능은 조화롭고 합리적인지, 
표출하려는 데이터가 정말로 우리가 필요한 데이터 인지에 대한 끊임없는 고민이 필요하다는 것을 깨달았다.

우리가 가지고 있는 데이터를 꼼꼼히 살펴서 이러한 기능을 현실적으로 구현할 수 있는지 없는지에 대한 끊임없는 고민이 필요했지만
그 당시 이러한 데이터를 가공할 수 있을 지에 대한 나의 실력에 물음표를 끊임없이 던질때였기에 이러한 과정을 소홀히 했던 것 같다.

### 7.2. 속도보다는 꼼꼼함
과업종료 기간은 12월 말이었지만, 팀 내부적인 목표는 9월말이었다.
하지만 컨소 회사와의 잦은 불협화음으로 인해 화면설계가 내부적으로 합의 되는데만 2개월이 걸렸고, 본격적으로 개발을 시작한 시기는 8월 초가 되었다.

그 당시 나는 스프링을 처음 접해보았기 때문에 기능을 구현할 수 있을지조차 미지수였다.
따라서 리팩토링, 데이터 정합성 등은 고민하지 않은 채 어떻게든 기능을 구현하고 화면에 표출시키는 데에만 집중했다.

기능만 어떤식으로든 구현하면 납품을 할 수 있을 것이라고 생각한 것은 너무 순진한 생각이었다.

실제로 감독관은 데이터 이상치와 정합성에 대해서 끊임없이 질문했고 그것에 대해 제대로 고민하지 않은 나는 진땀만 뺄뿐 아무말도 할 수 없었다.

지금에와서 다시 생각해보면 조금만 차분하게 생각했으면 얼마든지 기능은 구현할 수 있었고
데이터 하나하나를 꼼꼼하게 보는 것이 오히려 개발 기간을 단축시키는 방법이었다. 
학교 조별과제가 아니기에 정합성과 이상치는 어떤식으로든 검증을 하는 것이었고
그러한 것에 대해서 프로답게 책임을 져야 했다.

'천리 길도 한 걸음 부터', '돌다리도 두드려보고 건너기'는 개발자에게 있어 꼭 필요한 덕목인 것 같다.

</div>
</details>
